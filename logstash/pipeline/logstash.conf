input {
  beats {
    port => 5044
  }
}

filter {
    if "tsig verify failure" in[message] {
       drop { }
     }

if "Panorama" in[message] {
    if "app-id-change" in[message] {
            csv {
                source => "message"
                columns => [
                    "FUTURE_USE", "Receive Time", "Serial Number", "Type", "Threat Content Type", "FUTURE_USE", "Generated Time", "Source Address", "Destination Address", "NAT Source IP", "NAT Destination IP", "Rule Name", "Source User", "Destination User", "Application", "Virtual System", "Source Zone", "Destination Zone", "Inbound Interface", "Outbound Interface", "Log Action", "FUTURE_USE", "Session ID", "Repeat Count", "Source Port", "Destination Port", "NAT Source Port", "NAT Destination Port", "Flags", "Protocol", "Action", "URL Filename", "Threat ID", "Category", "Severity", "Direction", "Sequence Number", "Action Flags", "Source Location", "Destination Location", "FUTURE_USE", "Content Type", "PCAP_ID", "File Digest", "Cloud", "URL Index", "User Agent", "File Type", "X-Forwarded-For", "Referer", "Sender", "Subject", "Recipient", "Report ID", "Device Group Hierarchy Level 1", "Device Group Hierarchy Level 2", "Device Group Hierarchy Level 3", "Device Group Hierarchy Level 4", "Virtual System Name", "Device Name", "FUTURE_USE", "Source VM UUID", "Destination VM UUID", "HTTP Method", "Tunnel ID/IMSI", "Monitor Tag IMEI", "Parent Session ID", "Parent Start Time", "Tunnel Type", "Threat Category", "Content Version", "FUTURE_USE", "SCTP Association ID", "Payload Protocol ID", "HTTP Headers", "URL Category List", "Rule UUID", "HTTP2 Connection", "Dynamic User Group Name"
                ]
            }
    }
     if "artificial-intelligence" in[message] {   
             csv {
                source => "message"
                columns => [
                    "FUTURE_USE", "Receive Time", "Serial Number", "Type", "Threat Content Type", "FUTURE_USE", "Generated Time", "Source Address", "Destination Address", "NAT Source IP", "NAT Destination IP", "Rule Name", "Source User", "Destination User", "Application", "Virtual System", "Source Zone", "Destination Zone", "Inbound Interface", "Outbound Interface", "Log Action", "FUTURE_USE", "Session ID", "Repeat Count", "Source Port", "Destination Port", "NAT Source Port", "NAT Destination Port", "Flags", "Protocol", "Action", "URL Filename", "Threat ID", "Category", "Severity", "Direction", "Sequence Number", "Action Flags", "Source Location", "Destination Location", "FUTURE_USE", "Content Type", "PCAP_ID", "File Digest", "Cloud", "URL Index", "User Agent", "File Type", "X-Forwarded-For", "Referer", "Sender", "Subject", "Recipient", "Report ID", "Device Group Hierarchy Level 1", "Device Group Hierarchy Level 2", "Device Group Hierarchy Level 3", "Device Group Hierarchy Level 4", "Virtual System Name", "Device Name", "FUTURE_USE", "Source VM UUID", "Destination VM UUID", "HTTP Method", "Tunnel ID/IMSI", "Monitor Tag IMEI", "Parent Session ID", "Parent Start Time", "Tunnel Type", "Threat Category", "Content Version", "FUTURE_USE", "SCTP Association ID", "Payload Protocol ID", "HTTP Headers", "URL Category List", "Rule UUID", "HTTP2 Connection", "Dynamic User Group Name"
                ]
            }
    }
} 


        if "SSH2 Session from" in[message] {
                if "Succeeded" in[message] or "Failed" in[message] {
                        grok {
                                match => {"message" => "^*%%{DATA:Login_Method}: User%{DATA:User_Info} from %{IPV4:Source_IP}%{DATA:Ciphers}' %{DATA:Status}$"}
                        }
                }
        }


      grok {
        match => { "message" => "^*%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname}%{GREEDYDATA:syslog_message}" }
      }

                                mutate { add_field => { "Logstash_id" => "MYHOSTNAME_Logstash"} }

}
output {
        elasticsearch {
                hosts => ["10.11.0.18:9200","10.11.0.19:9200","10.11.0.20:9200"]    // Assuming we have multiple elastic search containers/servers in the Cluster
#               ilm_enabled => true
#               ilm_write_alias => "elogs"
#                ilm_rollover_alias => "elogs"
#               ilm_pattern => "{now/d}-000001"
#               ilm_policy => "kibana-reporting"
#                index =>  "elogs-%{+YYYY.MM.dd}"
                index =>  "elogs"
        }
}
